<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://sebsslpwthkybd.github.io/</id><title>Sebs抱着键盘睡觉</title><subtitle>这是通过Chirpy主题配置而成的</subtitle> <updated>2023-04-28T07:15:34+00:00</updated> <author> <name>Sebastian</name> <uri>https://sebsslpwthkybd.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://sebsslpwthkybd.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://sebsslpwthkybd.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator> <rights> © 2023 Sebastian </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title></title><link href="https://sebsslpwthkybd.github.io/posts/2023-04-18-unable_resolve_host/" rel="alternate" type="text/html" title="" /><published>2023-04-28T07:15:34+00:00</published> <updated>2023-04-28T07:15:34+00:00</updated> <id>https://sebsslpwthkybd.github.io/posts/2023-04-18-unable_resolve_host/</id> <content src="https://sebsslpwthkybd.github.io/posts/2023-04-18-unable_resolve_host/" /> <author> <name>Sebastian</name> </author> <summary> 错误信息： 使用sudo的时候需要等待特别久 sudo: unable to resolve host 172-16-200-220: Name or service not known 原理： 配置静态主机名后没有登记到hosts列表里，每次sudo都是一个提权的过程，穿透至root环境，会涉及到DNS解析主机名的过程，如果更换了静态主机名却没有记录下，DNS无法解析只能等待timeout时间然后才能提权至localhost的超级权限 解决方法： 将静态主机名加入hosts列表里 sudo vim /etc/hosts # 将主机名加到127.0.0.1后面 127.0.0.1 localhost &amp;lt;静态主机名&amp;gt; </summary> </entry> <entry><title>linux用户管理</title><link href="https://sebsslpwthkybd.github.io/posts/linux_user/" rel="alternate" type="text/html" title="linux用户管理" /><published>2023-03-16T08:00:00+00:00</published> <updated>2023-03-16T08:00:00+00:00</updated> <id>https://sebsslpwthkybd.github.io/posts/linux_user/</id> <content src="https://sebsslpwthkybd.github.io/posts/linux_user/" /> <author> <name>Sebastian Lee</name> </author> <category term="linux使用" /> <summary> linux用户管理 /etc/passwd文件 用户名:密码位(x):UID(五位数起步):GID(一般与UID相同):注释:用户目录:shell位置(/bin/bash) bashrc配置文件损坏或丢失 原版的bashrc配置文件位于 /etc/skel/.bashrc 恢复 cp /etc/skel/.bashrc ~/ source ~/.bashrc </summary> </entry> <entry><title>帆软学习</title><link href="https://sebsslpwthkybd.github.io/posts/zsh_theme/" rel="alternate" type="text/html" title="帆软学习" /><published>2023-03-16T08:00:00+00:00</published> <updated>2023-03-16T08:00:00+00:00</updated> <id>https://sebsslpwthkybd.github.io/posts/zsh_theme/</id> <content src="https://sebsslpwthkybd.github.io/posts/zsh_theme/" /> <author> <name>Sebastian Lee</name> </author> <category term="linux使用" /> <summary> 好看的皮肤（没有git） mortalscumbag 好看的皮肤（有git） cloud kolo muse * 奇怪的 jonathan </summary> </entry> <entry><title>帆软学习</title><link href="https://sebsslpwthkybd.github.io/posts/fine_report/" rel="alternate" type="text/html" title="帆软学习" /><published>2023-03-16T08:00:00+00:00</published> <updated>2023-03-16T08:00:00+00:00</updated> <id>https://sebsslpwthkybd.github.io/posts/fine_report/</id> <content src="https://sebsslpwthkybd.github.io/posts/fine_report/" /> <author> <name>Sebastian Lee</name> </author> <category term="fine-report" /> <summary> 正常流程 1、 获取需求：主要细节的就是和谁提的 和谁一边改一边确认 2、 完成需求： 帆软bi中导航栏-文件-切换工作目录-远程服务器2 添加报表 3、 打开前台页面-左侧导航栏-管理系统 目录管理-找到对应的目录下添加模板 在表中展示模板参数 =$参数名 准备数据 左下角模板数据集中，+-数据库查询-写sql 下方可以看到能获取到的字段名 拖动即可展示在表格上 数据项过滤条件 双击单元格-过滤 可选列 操作符 P（模板参数） 选择一个模板参数过滤 支持excel导入 导航栏-模板-模板web属性-填报页面设置 以下设置：为该模板单独设置 √使用工具栏 图表颜色 双击图表-右侧控件-单元格元素-特效 添加条件-配色-系列序号-等于-（1， +∞） 选中栏目变黑了 导航栏-模板-模板web属性-填... </summary> </entry> <entry><title>数据结构（递归和分治）</title><link href="https://sebsslpwthkybd.github.io/posts/data_structure-partition/" rel="alternate" type="text/html" title="数据结构（递归和分治）" /><published>2023-03-16T08:00:00+00:00</published> <updated>2023-03-16T08:00:00+00:00</updated> <id>https://sebsslpwthkybd.github.io/posts/data_structure-partition/</id> <content src="https://sebsslpwthkybd.github.io/posts/data_structure-partition/" /> <author> <name>Sebastian Lee</name> </author> <category term="C/C++" /> <summary> 折半查找 一个数组 先切分一半，按照中位元素判定是前半区还是后半区 将半区数组传入递归 不断切分直至中位元素关键字即为查找的元素 int BinSearch(RcdType rcd[], KeyType key, int low, int high) { int mid = (low + high) / 2; // 获得中位索引 if (low &amp;gt; high) return -1; // 传入错误 if (rcd[mid].key == key) return mid; // 查找到元素的情况 else if (rcd[mid].key &amp;gt; key) return BinSearch(rcd, key, low, mid-1); else return BinSearch(rcd, key, mid+1, high); } 归并排... </summary> </entry> </feed>
